/**
 * Generated by orval v7.10.0 ðŸº
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  useCallback
} from 'react';

import type {
  RecipeDTO
} from '../../model';

import { useCustomFetch } from '../../../utils/customFetch';




/**
 * Returns a recipe by its unique identifier
 * @summary Get recipe by ID
 */
export const useGetRecipeByIdHook = () => {
        const getRecipeById = useCustomFetch<RecipeDTO>();

        return useCallback((
    recipeId: number,
 signal?: AbortSignal
) => {
        return getRecipeById(
          {url: `http://localhost:1291/recipes/${recipeId}`, method: 'GET', signal
    },
          );
        }, [getRecipeById])
      }
    

export const getGetRecipeByIdQueryKey = (recipeId: number,) => {
    return [`http://localhost:1291/recipes/${recipeId}`] as const;
    }

    
export const useGetRecipeByIdQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError = unknown>(recipeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRecipeByIdQueryKey(recipeId);

  const getRecipeById =  useGetRecipeByIdHook();

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>> = ({ signal }) => getRecipeById(recipeId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(recipeId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetRecipeByIdQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>>
export type GetRecipeByIdQueryError = unknown


export function useGetRecipeById<TData = Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError = unknown>(
 recipeId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecipeById<TData = Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError = unknown>(
 recipeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetRecipeById<TData = Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError = unknown>(
 recipeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get recipe by ID
 */

export function useGetRecipeById<TData = Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError = unknown>(
 recipeId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetRecipeByIdHook>>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = useGetRecipeByIdQueryOptions(recipeId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Updates an existing recipe by its ID and returns the updated recipe
 * @summary Update an existing recipe
 */
export const useUpdateRecipeHook = () => {
        const updateRecipe = useCustomFetch<RecipeDTO>();

        return useCallback((
    recipeId: number,
    recipeDTO: RecipeDTO,
 ) => {
        return updateRecipe(
          {url: `http://localhost:1291/recipes/${recipeId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: recipeDTO
    },
          );
        }, [updateRecipe])
      }
    


export const useUpdateRecipeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateRecipeHook>>>, TError,{recipeId: number;data: RecipeDTO}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateRecipeHook>>>, TError,{recipeId: number;data: RecipeDTO}, TContext> => {

const mutationKey = ['updateRecipe'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const updateRecipe =  useUpdateRecipeHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useUpdateRecipeHook>>>, {recipeId: number;data: RecipeDTO}> = (props) => {
          const {recipeId,data} = props ?? {};

          return  updateRecipe(recipeId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRecipeMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useUpdateRecipeHook>>>>
    export type UpdateRecipeMutationBody = RecipeDTO
    export type UpdateRecipeMutationError = unknown

    /**
 * @summary Update an existing recipe
 */
export const useUpdateRecipe = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateRecipeHook>>>, TError,{recipeId: number;data: RecipeDTO}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useUpdateRecipeHook>>>,
        TError,
        {recipeId: number;data: RecipeDTO},
        TContext
      > => {

      const mutationOptions = useUpdateRecipeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Deletes a recipe by its ID and returns a success message
 * @summary Delete a recipe
 */
export const useDeleteRecipeHook = () => {
        const deleteRecipe = useCustomFetch<string>();

        return useCallback((
    recipeId: number,
 ) => {
        return deleteRecipe(
          {url: `http://localhost:1291/recipes/${recipeId}`, method: 'DELETE'
    },
          );
        }, [deleteRecipe])
      }
    


export const useDeleteRecipeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteRecipeHook>>>, TError,{recipeId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteRecipeHook>>>, TError,{recipeId: number}, TContext> => {

const mutationKey = ['deleteRecipe'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const deleteRecipe =  useDeleteRecipeHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useDeleteRecipeHook>>>, {recipeId: number}> = (props) => {
          const {recipeId} = props ?? {};

          return  deleteRecipe(recipeId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRecipeMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useDeleteRecipeHook>>>>
    
    export type DeleteRecipeMutationError = unknown

    /**
 * @summary Delete a recipe
 */
export const useDeleteRecipe = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteRecipeHook>>>, TError,{recipeId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useDeleteRecipeHook>>>,
        TError,
        {recipeId: number},
        TContext
      > => {

      const mutationOptions = useDeleteRecipeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Returns a list of all recipes created by the authenticated user
 * @summary Get all recipes by author ID
 */
export const useGetAllRecipesByAuthorIdHook = () => {
        const getAllRecipesByAuthorId = useCustomFetch<RecipeDTO[]>();

        return useCallback((
    
 signal?: AbortSignal
) => {
        return getAllRecipesByAuthorId(
          {url: `http://localhost:1291/recipes`, method: 'GET', signal
    },
          );
        }, [getAllRecipesByAuthorId])
      }
    

export const getGetAllRecipesByAuthorIdQueryKey = () => {
    return [`http://localhost:1291/recipes`] as const;
    }

    
export const useGetAllRecipesByAuthorIdQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllRecipesByAuthorIdQueryKey();

  const getAllRecipesByAuthorId =  useGetAllRecipesByAuthorIdHook();

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>> = ({ signal }) => getAllRecipesByAuthorId(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllRecipesByAuthorIdQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>>
export type GetAllRecipesByAuthorIdQueryError = unknown


export function useGetAllRecipesByAuthorId<TData = Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllRecipesByAuthorId<TData = Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllRecipesByAuthorId<TData = Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all recipes by author ID
 */

export function useGetAllRecipesByAuthorId<TData = Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllRecipesByAuthorIdHook>>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = useGetAllRecipesByAuthorIdQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Creates a new recipe and returns the created recipe
 * @summary Create a new recipe
 */
export const useCreateRecipeHook = () => {
        const createRecipe = useCustomFetch<RecipeDTO>();

        return useCallback((
    recipeDTO: RecipeDTO,
 signal?: AbortSignal
) => {
        return createRecipe(
          {url: `http://localhost:1291/recipes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: recipeDTO, signal
    },
          );
        }, [createRecipe])
      }
    


export const useCreateRecipeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateRecipeHook>>>, TError,{data: RecipeDTO}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateRecipeHook>>>, TError,{data: RecipeDTO}, TContext> => {

const mutationKey = ['createRecipe'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const createRecipe =  useCreateRecipeHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useCreateRecipeHook>>>, {data: RecipeDTO}> = (props) => {
          const {data} = props ?? {};

          return  createRecipe(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRecipeMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useCreateRecipeHook>>>>
    export type CreateRecipeMutationBody = RecipeDTO
    export type CreateRecipeMutationError = unknown

    /**
 * @summary Create a new recipe
 */
export const useCreateRecipe = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateRecipeHook>>>, TError,{data: RecipeDTO}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useCreateRecipeHook>>>,
        TError,
        {data: RecipeDTO},
        TContext
      > => {

      const mutationOptions = useCreateRecipeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    