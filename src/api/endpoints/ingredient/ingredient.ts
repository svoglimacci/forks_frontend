/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  useCallback
} from 'react';

import type {
  DeleteIngredient200,
  GetAllIngredients200,
  IngredientDTO
} from '../../model';

import { useCustomFetch } from '../../../utils/customFetch';




/**
 * Returns an ingredient by its unique identifier
 * @summary Get ingredient by ID
 */
export const useGetIngredientByIdHook = () => {
        const getIngredientById = useCustomFetch<IngredientDTO>();

        return useCallback((
    ingredientId: number,
 signal?: AbortSignal
) => {
        return getIngredientById(
          {url: `http://localhost:1291/ingredients/${ingredientId}`, method: 'GET', signal
    },
          );
        }, [getIngredientById])
      }
    

export const getGetIngredientByIdQueryKey = (ingredientId: number,) => {
    return [`http://localhost:1291/ingredients/${ingredientId}`] as const;
    }

    
export const useGetIngredientByIdQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError = unknown>(ingredientId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetIngredientByIdQueryKey(ingredientId);

  const getIngredientById =  useGetIngredientByIdHook();

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>> = ({ signal }) => getIngredientById(ingredientId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(ingredientId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetIngredientByIdQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>>
export type GetIngredientByIdQueryError = unknown


export function useGetIngredientById<TData = Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError = unknown>(
 ingredientId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIngredientById<TData = Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError = unknown>(
 ingredientId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetIngredientById<TData = Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError = unknown>(
 ingredientId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get ingredient by ID
 */

export function useGetIngredientById<TData = Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError = unknown>(
 ingredientId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetIngredientByIdHook>>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = useGetIngredientByIdQueryOptions(ingredientId,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Updates an existing ingredient by its ID and returns the updated ingredient
 * @summary Update an existing ingredient
 */
export const useUpdateIngredientHook = () => {
        const updateIngredient = useCustomFetch<IngredientDTO>();

        return useCallback((
    ingredientId: number,
    ingredientDTO: IngredientDTO,
 ) => {
        return updateIngredient(
          {url: `http://localhost:1291/ingredients/${ingredientId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: ingredientDTO
    },
          );
        }, [updateIngredient])
      }
    


export const useUpdateIngredientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateIngredientHook>>>, TError,{ingredientId: number;data: IngredientDTO}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateIngredientHook>>>, TError,{ingredientId: number;data: IngredientDTO}, TContext> => {

const mutationKey = ['updateIngredient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const updateIngredient =  useUpdateIngredientHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useUpdateIngredientHook>>>, {ingredientId: number;data: IngredientDTO}> = (props) => {
          const {ingredientId,data} = props ?? {};

          return  updateIngredient(ingredientId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateIngredientMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useUpdateIngredientHook>>>>
    export type UpdateIngredientMutationBody = IngredientDTO
    export type UpdateIngredientMutationError = unknown

    /**
 * @summary Update an existing ingredient
 */
export const useUpdateIngredient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useUpdateIngredientHook>>>, TError,{ingredientId: number;data: IngredientDTO}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useUpdateIngredientHook>>>,
        TError,
        {ingredientId: number;data: IngredientDTO},
        TContext
      > => {

      const mutationOptions = useUpdateIngredientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Deletes an ingredient by its ID and returns a success message
 * @summary Delete an ingredient
 */
export const useDeleteIngredientHook = () => {
        const deleteIngredient = useCustomFetch<DeleteIngredient200>();

        return useCallback((
    ingredientId: number,
 ) => {
        return deleteIngredient(
          {url: `http://localhost:1291/ingredients/${ingredientId}`, method: 'DELETE'
    },
          );
        }, [deleteIngredient])
      }
    


export const useDeleteIngredientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteIngredientHook>>>, TError,{ingredientId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteIngredientHook>>>, TError,{ingredientId: number}, TContext> => {

const mutationKey = ['deleteIngredient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const deleteIngredient =  useDeleteIngredientHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useDeleteIngredientHook>>>, {ingredientId: number}> = (props) => {
          const {ingredientId} = props ?? {};

          return  deleteIngredient(ingredientId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteIngredientMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useDeleteIngredientHook>>>>
    
    export type DeleteIngredientMutationError = unknown

    /**
 * @summary Delete an ingredient
 */
export const useDeleteIngredient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteIngredientHook>>>, TError,{ingredientId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useDeleteIngredientHook>>>,
        TError,
        {ingredientId: number},
        TContext
      > => {

      const mutationOptions = useDeleteIngredientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * Returns a list of all ingredients
 * @summary Get all ingredients
 */
export const useGetAllIngredientsHook = () => {
        const getAllIngredients = useCustomFetch<GetAllIngredients200>();

        return useCallback((
    
 signal?: AbortSignal
) => {
        return getAllIngredients(
          {url: `http://localhost:1291/ingredients`, method: 'GET', signal
    },
          );
        }, [getAllIngredients])
      }
    

export const getGetAllIngredientsQueryKey = () => {
    return [`http://localhost:1291/ingredients`] as const;
    }

    
export const useGetAllIngredientsQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllIngredientsQueryKey();

  const getAllIngredients =  useGetAllIngredientsHook();

    const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>> = ({ signal }) => getAllIngredients(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllIngredientsQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>>
export type GetAllIngredientsQueryError = unknown


export function useGetAllIngredients<TData = Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllIngredients<TData = Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>,
          TError,
          Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllIngredients<TData = Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get all ingredients
 */

export function useGetAllIngredients<TData = Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetAllIngredientsHook>>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = useGetAllIngredientsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * Creates a new ingredient and returns the created ingredient
 * @summary Create a new ingredient
 */
export const useCreateIngredientHook = () => {
        const createIngredient = useCustomFetch<IngredientDTO>();

        return useCallback((
    ingredientDTO: IngredientDTO,
 signal?: AbortSignal
) => {
        return createIngredient(
          {url: `http://localhost:1291/ingredients`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ingredientDTO, signal
    },
          );
        }, [createIngredient])
      }
    


export const useCreateIngredientMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateIngredientHook>>>, TError,{data: IngredientDTO}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateIngredientHook>>>, TError,{data: IngredientDTO}, TContext> => {

const mutationKey = ['createIngredient'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      const createIngredient =  useCreateIngredientHook()


      const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useCreateIngredientHook>>>, {data: IngredientDTO}> = (props) => {
          const {data} = props ?? {};

          return  createIngredient(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateIngredientMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useCreateIngredientHook>>>>
    export type CreateIngredientMutationBody = IngredientDTO
    export type CreateIngredientMutationError = unknown

    /**
 * @summary Create a new ingredient
 */
export const useCreateIngredient = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useCreateIngredientHook>>>, TError,{data: IngredientDTO}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<ReturnType<typeof useCreateIngredientHook>>>,
        TError,
        {data: IngredientDTO},
        TContext
      > => {

      const mutationOptions = useCreateIngredientMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    